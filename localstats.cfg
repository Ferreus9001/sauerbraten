// File:        localstats.cfg
// Author:      FerreusRemedium
// Created:     2013-03-13
// Last Change: 2013-03-22


// TODO use 2d lists for filters



// ==================
//  Helper Functions
// ==================



createine = [ if (=s (getalias $arg1) "") [ $arg1 = $arg2 ] ]


|= = [$arg1 = (| (getalias $arg1) $arg2)]
+= = [$arg1 = (+ (getalias $arg1) $arg2)]
-= = [$arg1 = (- (getalias $arg1) $arg2)]
++ = [$arg1 = (+ (getalias $arg1) 1)]
-- = [$arg1 = (- (getalias $arg1) 1)]

// Checks whether the gametype is neither insta nor effic.
_ls_m_normal = [ && [! (m_insta $arg1)] [! (m_efficiency $arg1)] ]

// Ensures 2 digits by prepending zeros.
_ls_zeros = [ concatword (loopconcatword i (- $arg2 (strlen $arg1)) [result 0]) $arg1 ]

// _ls_display_byindex <COUNTERS> <COUNTER>
_ls_display_byindex = [
	local disp
	disp = (at $arg1 $arg2)
	if (_ls_f_isnumeric (_ls_getcounterflags $arg2)) [
		|| [result $disp] [result $_ls_nostats_string]
	] [
		if (!=s $disp "") [
			result $disp
		] [
			result $_ls_nostats_string
		]
	]
]

// _ls_round <F>
// Rounds float F to int.
_ls_round = [
	if (>= $arg1 0) [
		+ (+f $arg1 0.5) 0
	] [
		+ (-f $arg1 0.5) 0
	]
]

// _ls_round <F> <MUL>
// Rounds float F to a number of places.
// F:     The number.
// MUL:   10 to the number of decimal places'th power. (e.g. 100 for 2 places)
_ls_round2 = [
	divf (_ls_round (*f $arg1 $arg2)) $arg2
]


// _ls_getstrtimesub <SECONDS> <SUFFIX> <DIV> [<MOD>] [<N>]
// Returns ((SECONS / DIV) % MOD) and appends SUFFIX.
// If the number without MOD equals or is greater than DIV, it ensures N digits (default: 2).
// If the number is zero, it returns an empty string.
// If MOD is omitted or 0 it counts as a really big number.
_ls_getstrtimesub = [
	local s
	if (< $arg1 $arg3) [
		result ""
	] [
		if $arg4 [
			if (>= $arg1 (* $arg3 $arg4)) [
				concatword (_ls_zeros (mod (div $arg1 $arg3) $arg4) (|| [result $arg5] [result 2])) $arg2
			] [
				concatword (mod (div $arg1 $arg3) $arg4) $arg2
			]
		] [
			concatword (div $arg1 $arg3) $arg2
		]
	]
]

// _ls_getstrtime <SECONDS>
// Returns a string-representation of a time.
// SECONDS: The time in seconds.
_ls_getstrtime = [
	concatword (_ls_getstrtimesub $arg1 "h" 3600) (_ls_getstrtimesub $arg1 "m" 60 60) (_ls_getstrtimesub $arg1 "s" 1 60)
]





// =======
//  Lists
// =======



// Normal counters
// Shall not be changed after exec
// TODO 2d lists
//                         0            1         2          3               4              5             6        7           8                 9       10      11
_ls_list_counters       = "_ls_getfrags getdeaths _ls_gettks _ls_getsuicides gettotaldamage gettotalshots getflags _ls_gettime _ls_getroundcount mapname getmode _ls_getmaxstreak"
_ls_list_counters_flags = "0x16         0x16      0x16       0x16            0x16           0x16          0x16     0x16        0x16              0x1     0x3     0xA"
//_ls_list_counters = [
	//[0x16 _ls_getfrags]
	//[0x16 getdeaths]
	//[0x16 _ls_gettks]
	//[0x16 _ls_getsuicides]
	//[0x16 gettotaldamage]
	//[0x16 gettotalshots]
	//[0x16 getflags]
	//[0x16 _ls_gettime]
	//[0x16 _ls_getroundcount]
	//[0x01 mapname]
	//[0x03 getmode]
	//[0x0A _ls_getmaxstreak]
//]

// Functions called to display the counters
// TODO 2d lists
_ls_list_displays         = "Mode:        Map: Time:        Games: Frags: Deaths: Tks: Suicides: K/D:        K/M:        Damage: Shots: Acc:             Scores:  Streak:"
_ls_list_displays_getters = "_ls_dispmode #9   _ls_disptime #8     #0     #1      #2   #3        _ls_dispkpd _ls_dispkpm #4      #5     _ls_dispaccuracy #6       #11"
_ls_list_displays_flags   = "0xC          0xC  0xF          0x1    0xF    0xF     0xF  0xF       0xF         0xF         0xF     0xF    0xF              0xF      0xF"
//_ls_list_displays = [
	//[0xC _ls_dispmode Mode:]
	//[0xC #9 Map:]
	//[0xF #0 Frags:]
	//[0xF #1 Deaths:]
	//[0xF #2 Tks:]
	//[0xF #3 Suicides:]
	//[0xF #4 Damage:]
	//[0xF #5 Shots:]
	//[0xF #6 Scores:]
	//[0xF _ls_disptime Time:]
	//[0x1 #8 Games:]
	//[0xF _ls_dispaccuracy Acc:]
	//[0xF _ls_dispkpd K/D:]
	//[0xF _ls_dispkpm K/M:]
	//[0xF #11 Streak:]
//]

_ls_flag_counter_static  = 0x1
_ls_flag_counter_numeric = 0x2
_ls_flag_counter_add     = 0x4
_ls_flag_counter_maximum = 0x8
_ls_flag_counter_diff    = 0x10

_ls_flag_showin_total   = 0x1
_ls_flag_showin_current = 0x2
_ls_flag_showin_history = 0x4
_ls_flag_showin_message = 0x8
_ls_mask_showin_any     = 0xF

// Gamemode filters
// TODO
_ls_list_filters        = "ffa team   . . . insta . effic      . . . ctf . protect . collect . hold . . . capture . regen        . tactics . sp . dmsp"
_ls_list_filters_checks = "m_teammode .   m_insta m_efficiency .   m_ctf m_protect m_collect m_hold .   m_capture m_regencapture m_tactics m_sp m_dmsp"

// Included gamemodes
_ls_list_modes       = "-3 -2 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22"
// not used yet
_ls_list_modes_names = "sp dmsp ffa teamplay instagib instateam effic efficteam tactics tacteam capture regen ctf instactf protect instaprotect hold instahold efficctf efficprotect effichold collect instacollect efficcollect"

_ls_killstreak_2 = "^f0[[[ ^f6Double Kill%2 ^f0]]]"
_ls_killstreak_3 = "^f0[[[ ^f6Triple Kill%2 ^f0]]]"
_ls_killstreak_any = "^f0[[[ ^f6%1 MULTIPLE KILLS%2 ^f0]]]" 

// teammodes:   ffa teamplay
// teamplay:    none ctf protect hold collect
// gearmodes:   none insta effic
// uniqueffa:   tactics
// uniqueteam:  tacteam capture regen

createine _ls_last_isconnected 0
createine _ls_last_mode -128
createine _ls_last_timeremaining 0
createine _ls_last_deaths 0

createine _ls_setting_save_current 1
createine _ls_setting_save_reactivate 1
createine _ls_setting_save_history_always 0
createine _ls_setting_echo_killstreak 1
createine _ls_setting_echo_postgame 1
createine _ls_setting_settings_advanced 0

createine _ls_setting_tkpollinterval 20
createine _ls_setting_pollinterval 100
createine _ls_setting_history_max 50
createine _ls_setting_history_tabrows 25
createine _ls_setting_killstreak_timeout 2000

createine _ls_current_tks 0
createine _ls_current_suicides 0
createine _ls_current_fragpenalties 0
createine _ls_current_streak 0
createine _ls_current_maxstreak 0
createine _ls_current_lastfrag 0
if (> $_ls_current_lastfrag (getmillis)) [_ls_current_lastfrag = 0]

createine _ls_filter_enabled 0

// History vars
createine _ls_history_count 0

_ls_nostats_string = "-"

// TODO filters
_ls_reset_all = [
	_ls_reset_history
	_ls_reset_current
	_ls_reset_stats
	_ls_reset_settings
]

_ls_reset_current = [
	//_ls_current_tks = 0
	//_ls_current_suicides = 0
	//_ls_current_fragpenalties = 0
	//_ls_current_streak = 0
	//_ls_current_maxstreak = 0
	//_ls_current_lastfrag = 0

	_ls_last_isconnected = 0
	_ls_last_mode = -128
	_ls_last_timeremaining = 0
	_ls_last_deaths = 0

	_ls_setstats START ""
	_ls_setstats END ""
]

// FIXME does not work correctly when in game
_ls_reset_stats = [
	loop i (listlen $_ls_list_modes) [
		_ls_setstats (at $_ls_list_modes $i) ""
	]
	_ls_setstats LAST ""
]

_ls_reset_history = [
	_ls_checkhistorylimit 0
]

_ls_reset_settings = [
	_ls_setting_save_current = 1
	_ls_setting_save_reactivate = 1
	_ls_setting_save_history_always = 0
	_ls_setting_echo_killstreak = 1
	_ls_setting_echo_postgame = 1
	_ls_setting_settings_advanced = 0

	_ls_setting_tkpollinterval = 20
	_ls_setting_pollinterval = 100
	_ls_setting_history_max = 50
	_ls_setting_history_tabrows = 25
	_ls_setting_killstreak_timeout = 2000

	_ls_filter_enabled = 0

	_ls_checkhistorylimit
]




// ==============================
//  Teamkill and Suicide polling
// ==============================



// stop already running versions
_ls_polltksd = []
sleep (* 2 $_ls_setting_tkpollinterval) [
	// polls frags and deaths to count tks
	_ls_polltksd = [
		sleep $_ls_setting_tkpollinterval [
			local fcmp dcmp tcmp
			fcmp = (- (getfrags) @(getfrags))
			dcmp = (- (getdeaths) @(getdeaths))
			tcmp = (- (timeremaining) @(timeremaining))
			if (< $fcmp 0) [
				//echo fcmp= $fcmp dcmp= $dcmp tcmp= $tcmp
				if (&& [>= $dcmp 0] [<= $tcmp 0]) [ // in case the game has ended
					-= _ls_current_tks (+ $fcmp $dcmp)
					+= _ls_current_suicides $dcmp
					-= _ls_current_fragpenalties $fcmp
					// XXX DEBUG
					echo tks: $_ls_current_tks suicides: $_ls_current_suicides penalties: $_ls_current_fragpenalties
				]
			] [
				if (> $fcmp 0) [
					if (&& [>= $dcmp 0] [<= $tcmp 0]) [ // in case the game has ended
						//echo fcmp= $fcmp dcmp= $dcmp tcmp= $tcmp
						if (> (- (getmillis) $_ls_current_lastfrag) $_ls_setting_killstreak_timeout) [
							_ls_current_streak = $fcmp
						] [
							+= _ls_current_streak $fcmp
						]
						echo "--- current streak:" $_ls_current_streak "millis:" (getmillis) "fcmp:" $fcmp "---"
						_ls_current_maxstreak = (max $_ls_current_maxstreak $_ls_current_streak)
						_ls_onkill $_ls_current_streak
						_ls_current_lastfrag = (getmillis)
					]
				]
			]
			_ls_polltksd
		]
	]
	_ls_polltksd
]

// _ls_onkill <STREAK>
_ls_onkill = [
	if $_ls_setting_echo_killstreak [
		if (> $arg1 1) [
			local s
			s = (getalias (concatword _ls_killstreak_ $arg1))
			if (=s $s "") [
				s = $_ls_killstreak_any
			]
			echo (format $s $arg1 (loopconcatword i $arg1 [result "!"]))
		]
	]
]





// =======
//  Flags
// =======



// _ls_getcounterflags <COUNTER>
_ls_getcounterflags = [
	at $_ls_list_counters_flags $arg1
]

// _ls_f_isnumeric <FLAGS>
_ls_f_isnumeric = [
	& $arg1 $_ls_flag_counter_numeric
]

// _ls_f_isstatic <FLAGS>
_ls_f_isstatic = [
	& $arg1 $_ls_flag_counter_static
]

// _ls_f_isaddcounter <FLAGS>
_ls_f_isaddcounter = [
	& $arg1 $_ls_flag_counter_add
]

_ls_f_isdiffcounter = [
	& $arg1 $_ls_flag_counter_diff
]

_ls_f_ismaxcounter = [
	& $arg1 $_ls_flag_counter_maximum
]





// ================
//  Stats counting
// ================



// _ls_singlecounterlist <COUNTER> <VALUE>
_ls_singlecounterlist = [
	concat (loopconcat i $arg1 [result 0]) $arg2
]

// _ls_findcounter <GETTER>
// Returns a counter index by getter.
_ls_findcounter = [
	indexof $_ls_list_counters $arg1
]

_ls_numcounters = [
	listlen $_ls_list_counters
]

// _ls_getcounter <COUNTERS> <COUNTER>
_ls_getcounter = [
	if (< $arg2 (listlen $arg1)) [
		at $arg1 $arg2
	] [
		result 0
	]
]

// _ls_opcounters <OP> <LIST1> [<LIST2>]
_ls_opcounters = [
	if (> $numargs 2) [
		loopconcat i @@(_ls_numcounters) [
			concat ($arg1 (_ls_getcounter $arg2 $i) (_ls_getcounter $arg3 $i) (_ls_getcounterflags $i))
		]
	] [
		loopconcat i @@(_ls_numcounters) [
			concat ($arg1 (_ls_getcounter $arg2 $i) (_ls_getcounterflags $i))
		]
	]
]

_ls_applycounters_op = [
	//if (getalias _ls_DEBUG) [echo _ls_applycounters_op | $arg1 | $arg2 | $arg3 |]
	cond [_ls_f_isaddcounter $arg3] [
		+ $arg1 $arg2
	] [_ls_f_ismaxcounter $arg3] [
		max $arg1 $arg2
	] [
		result $arg1
	]
]

_ls_diffcounters_op = [
	//if (getalias _ls_DEBUG) [echo _ls_diffcounters_op | $arg1 | $arg2 | $arg3 |]
	cond [_ls_f_isdiffcounter $arg3] [
		- $arg1 $arg2
	] [_ls_f_ismaxcounter $arg3] [
		max $arg1 $arg2
	] [
		result $arg1
	]
]

// _ls_applycounters <LIST1> <LIST2>
_ls_applycounters = [
	_ls_opcounters _ls_applycounters_op $arg1 $arg2
]

// _ls_diffcounters <LIST1> <LIST2>
_ls_diffcounters = [
	_ls_opcounters _ls_diffcounters_op $arg1 $arg2
]





// =========
//   Stats
// =========



// _ls_getstatsname <TAG>
_ls_getstatsname = [
	concatword _ls_stats_ $arg1
]

// _ls_setstats <TAG> <COUNTERS>
_ls_setstats = [
	(_ls_getstatsname $arg1) = $arg2
]

// _ls_applystats <TAG> <COUNTERS>
_ls_applystats = [
	(_ls_getstatsname $arg1) = (_ls_applycounters $arg2 (_ls_getstats $arg1))
]

// _ls_getstats
_ls_getstats = [
	getalias (_ls_getstatsname $arg1)
]

// _ls_getstats_current
_ls_getstats_current = [
	_ls_diffcounters (_ls_getstats END) (_ls_getstats START)
]

// _ls_getcurrentcounter <COUNTER>
_ls_getcurrentcounter = [
	local val
	val = ((at $_ls_list_counters $arg1))
	cond [_ls_f_isnumeric (_ls_getcounterflags $arg1)] [
		|| [result $val] [result 0]
	] [!=s $val ""] [
		result $val
	] [
		result 0
	]
]

// _ls_getcurrentcounters
_ls_getcurrentcounters = [
	loopconcat i @(_ls_numcounters) [
		_ls_getcurrentcounter $i
	]
]

// _ls_apply_tmp <TAG>
// saves current game stats to temporary vars
// TAG: END or START
_ls_apply_tmp = [
	local _ls_setstats_tmp_tag
	_ls_setstats_tmp_tag = $arg1
	(_ls_getstatsname $arg1) = (_ls_getcurrentcounters)
]




// ==========
//  Displays
// ==========



// _ls_getdisplayflags <DISPLAY>
_ls_getdisplayflags = [
	at $_ls_list_displays_flags $arg1
]

// _ls_getdisplaytitle <DISPLAY>
_ls_getdisplaytitle = [
	at $_ls_list_displays $arg1
]

// _ls_getdisplaygetter <DISPLAY>
_ls_getdisplaygetter = [
	at $_ls_list_displays_getters $arg1
]

// _ls_getdisplaycount <FLAGS>
_ls_getdisplaycount = [
	local count
	loop i (listlen $_ls_list_displays) [
		if (& (_ls_getdisplayflags $i) $arg1) [
			++ count
		]
	]
	result $count
]

// _ls_loopdisplays <VARCAPTION> <VARDISP> <COUNTERS> <MASK> <ACTION>
_ls_loopdisplays = [
	local mask action $arg1 $arg2 .
	local @(loopconcat i (listlen $_ls_list_counters) [concatword # $i])

	// _ls_getdisplayvalue <LIST> <DISPLAY>
	_ls_getdisplayvalue = [
		(_ls_getdisplaygetter $arg2) $arg1
	]

	// Getters:
	// getter <COUNTERS>

	if (> $numargs 4) [
		mask = $arg4
		action = $arg5
	] [
		mask = $_ls_mask_showin_all
		action = $arg4
	]

	// create #n display functions
	loop i (listlen $_ls_list_counters) [
		// _ls_display_byindex <COUNTERS> <COUNTER>
		(concatword # $i) = (concatword _ls_display_byindex " $arg1 " $i)
	]
	loopconcatword d (listlen $_ls_list_displays) [
		if (& (_ls_getdisplayflags $d) $mask) [
			$arg1 = (_ls_getdisplaytitle $d)
			$arg2 = (_ls_getdisplayvalue $arg3 $d)
			action
		]
	]
]





// =========
//  History
// =========



_ls_gethistory = [ getalias _ls_history ]
_ls_gethistorylength = [ listlen (_ls_gethistory) ]

// _ls_addhistory <COUNTERS>
_ls_addhistory = [
	_ls_history = (sublist (concat [[@@arg1]] (_ls_gethistory)) 0 $_ls_setting_history_max)
]

// _ls_rmhistory <ENTRY>
_ls_rmhistory = [
	_ls_history = (listsplice (_ls_gethistory) "" $arg1 1)
]

// _ls_checkhistorylimit [<LIMIT>]
// Deletes history entries exceeding the history limit.
// Default: $_ls_setting_history_max
_ls_checkhistorylimit = [
	if (< $numargs 1) [
		arg1 = $_ls_setting_history_max
	]
	_ls_history = (sublist (_ls_gethistory) 0 $arg1)
]





// ===============
//  Stats polling
// ===============



// _ls_ismodecounted
_ls_ismodecounted = [
	>= (indexof $_ls_list_modes $arg1) 0
]

// _ls_apply
// Adds temporary counters to permanent counters
_ls_apply = [
	local addit counters
	addit = (_ls_ismodecounted $_ls_last_mode)
	// XXX DEBUG
	echo addit= $addit mode= $_ls_last_mode
	if $addit [
		counters = (_ls_getstats_current)
		_ls_setstats LAST $counters
		if $_ls_setting_save_current [
			_ls_applystats $_ls_last_mode $counters
		]
		if (|| [result $_ls_setting_save_current] [result $_ls_setting_save_history_always]) [
			//_ls_shifthistory
			//_ls_sethistorystats 0 $counters
			_ls_addhistory $counters
		]
		result 1
	] [
		result 0
	]
]

// _ls_getgamestate 
// checks whether the last game has ended
// FIXME
// Does not return 0 if the game is changed when all are true:
//  1. The game is switched directly without leaving the game to the main menu
//  2. The time remaining in the new game is less than in the old game
//  3. The player did not have any deaths in the old game
//  4. The new game is on the same mode as the old game
_ls_status_gamestarted = 0x1
_ls_status_gameended = 0x2
if (<= (timeremaining) 0) [_ls_state_waiting1second = 0]
_ls_getgamestate = [
	local status
	status = 0
	cond [|| [!= (isconnected) $_ls_last_isconnected] [> (timeremaining) $_ls_last_timeremaining] [< (getdeaths) $_ls_last_deaths] [!= (getmode) $_ls_last_mode]] [
		|= status $_ls_status_gamestarted
		|= status $_ls_status_gameended
		_ls_state_waiting1second = 0
	] [&& [<= (timeremaining) 0] [! (m_edit (getmode))]] [
		case $_ls_state_waiting1second 0 [
			_ls_state_waiting1second = 1
			sleep 1000 [
				if (= $_ls_state_waiting1second 1) [
					_ls_state_waiting1second = 2
				]
			]
		] 2 [
			|= status $_ls_status_gameended
		]
	] [
		_ls_state_waiting1second = 0
	]
	result $status
]

// _ls_savegameinfo
// saves information about current game for _ls_changedgame
_ls_savegameinfo = [
	_ls_last_mode = (getmode)
	_ls_last_isconnected = (isconnected)
	_ls_last_timeremaining = (timeremaining)
	_ls_last_deaths = (getdeaths)
]

// _ls_ongameended
// Called after a game has ended.
_ls_ongameended = [
	local applied
	// XXX DEBUG
	//echo "round ended"
	applied = (_ls_apply)
	if (&& [result $applied] [result $_ls_setting_echo_postgame]) [
		// TODO use variables for delay time
		sleep (? (&& [isconnected] [= (timeremaining) 0]) 2000 0) [
			echo (concatword "^f0Stats of last game:" (
				_ls_loopdisplays caption disp (_ls_getstats LAST) $_ls_flag_showin_message [
					if (!=s $disp $_ls_nostats_string) [
						concatword " " $caption " ^fs^f6" $disp "^fr"
					]
				]
			))
		]
	]

	//echo "---- resetting current ----"
	_ls_current_tks = 0
	_ls_current_suicides = 0
	_ls_current_fragpenalties = 0
	_ls_current_streak = 0
	_ls_current_maxstreak = 0
	_ls_current_lastfrag = 0

	// user hook
	if (!=s (getalias ongameended) "") [
		sleep 1 [ongameended @applied]
	]
	if $_ls_setting_save_reactivate [
		_ls_setting_save_current = 1
	]
	_ls_updategui
]

_ls_ongamestarted = [
	// XXX DEBUG
	//echo "round started"

	// user hook
	if (!=s (getalias ongamestarted) "") [
		sleep 1 [ongamestarted]
	]
	_ls_apply_tmp START
	// XXX DEBUG
	//echo APPLYSTART: (_ls_getcurrentcounters)
	//sleep 500 [ echo APPLYSTART2: (_ls_getcurrentcounters) ]
	_ls_updategui_total
]

// _ls_statscheck
_ls_statscheck = [
	_ls_savegameinfo
	if (!= $_ls_last_status $_ls_status_gameended) [
		_ls_apply_tmp END
	]
]

createine _ls_last_status 0

// _ls_pollstatsd
_ls_pollstatsd = [] // stop already running instances
sleep (* 2 $_ls_setting_pollinterval) [
	_ls_pollstatsd = [
		local status
		status = (_ls_getgamestate)
		if (!= $status $_ls_last_status) [
			// XXX DEBUG
			echo "--- status: " $status " ---"
			// TODO improve conditions
			if (&& [& $status $_ls_status_gameended] [! (& $_ls_last_status $_ls_status_gameended)]) [
				_ls_ongameended
			]
			if (&& [& $status $_ls_status_gamestarted] [! (& $_ls_last_status $_ls_status_gamestarted)]) [
				_ls_ongamestarted
			]
			_ls_last_status = $status
		]
		_ls_statscheck

		sleep $_ls_setting_pollinterval [_ls_pollstatsd]
	]
	_ls_pollstatsd
]





// =================
//  Special getters
// =================


_ls_getfrags = [
	+ (getfrags) $_ls_current_fragpenalties
]

// Returns tks counted by _ls_polltksd
_ls_gettks = [
	result $_ls_current_tks
]

// Returns suicides counted by _ls_polltksd
_ls_getsuicides = [
	result $_ls_current_suicides
]

_ls_getmaxstreak = [
	result $_ls_current_maxstreak
]

// _ls_gettime
// Returns time in seconds
_ls_gettime = [
	div (getmillis) 1000
]

_ls_fixroundcount = [
	if (= $arg2 @(_ls_findcounter "_ls_getroundcount")) [
		result 0
	] [
		result (at $arg1 $arg2)
	]
]

// _ls_getroundcount
// Returns whether the game has been longer than 60 seconds.
_ls_getroundcount = [
	if (=s (getalias _ls_setstats_tmp_tag) START) [
		// check does not work when START is applied
		result 0
	] [
		>= (_ls_getcounter (_ls_getstats_current) @@(_ls_findcounter "_ls_gettime")) 60
	]
]





// ===================
//  Display Functions
// ===================



// _ls_disptime <COUNTERS>
// Returns the game time as a string.
_ls_disptime = [
	local time
	time = (_ls_getcounter $arg1 @(_ls_findcounter "_ls_gettime"))
	if (> $time 0) [
		result (_ls_getstrtime $time)
	] [
		result $_ls_nostats_string
	]
]

// _ls_dispaccuracy <COUNTERS>
// Returns accuracy.
_ls_dispaccuracy = [
	local damage shots
	damage = (_ls_getcounter $arg1 @(_ls_findcounter "gettotaldamage"))
	shots = (_ls_getcounter $arg1 @(_ls_findcounter "gettotalshots"))
	if $damage [
		concatword (+ (*f (divf $damage $shots) 100) 0) "%"
	] [
		result $_ls_nostats_string
	]
]

// _ls_dispkpd <COUNTERS>
// Returns frags per death.
_ls_dispkpd = [
	local frags deaths
	frags = (_ls_getcounter $arg1 @(_ls_findcounter "getfrags"))
	deaths = (_ls_getcounter $arg1 @(_ls_findcounter "getdeaths"))
	if $frags [
		_ls_round2 (divf $frags (max $deaths 1)) 100
	] [
		result $_ls_nostats_string
	]
]

// _ls_dispkpm <COUNTERS>
// Returns frags per minute.
_ls_dispkpm = [
	local frags minutes
	//frags = (at $arg1 (indexof $_ls_list_counters "getfrags"))
	frags = (_ls_getcounter $arg1 @(_ls_findcounter "getfrags"))
	minutes = (divf (_ls_getcounter $arg1 @(_ls_findcounter "_ls_gettime")) 60)
	if (&& [result $frags] [result $minutes]) [
		_ls_round2 (divf $frags (maxf $minutes 0.01)) 100
	] [
		result $_ls_nostats_string
	]
]

// _ls_dispmode <COUNTERS>
_ls_dispmode = [
	local i
	i = (indexof $_ls_list_modes (_ls_getcounter $arg1 @(_ls_findcounter "getmode")))
	if (>= $i 0) [
		at $_ls_list_modes_names $i
	] [
		result $_ls_nostats_string
	]
]





// ===========
//  GUI stuff
// ===========



// _ls_getfiltername <FILTER> <ONOFF>
// ONOFF: 0 for the "on" variable, 1 for the true/false variable.
_ls_getfiltername = [
	concatword _ls_filter_ $arg1 _ $arg2
]

// _ls_genfilter <FILTER>
// Adds filter controls to the gui.
_ls_genfilter = [
	local ctrls falsetext truetext
	falsetext = (at $_ls_list_filters (<< $arg1 1))
	truetext = (at $_ls_list_filters (+ (<< $arg1 1) 1))

	ctrls = [guicheckbox "on" [@@(_ls_getfiltername $arg1 0)] 1 0 [_ls_updategui_total]]
	case (+ (!=s $truetext ".") (!=s $falsetext ".")) 2 [
		createine (_ls_getfiltername $arg1 0) 0
		createine (_ls_getfiltername $arg1 1) 1
		ctrls = (concat $ctrls [
			guistrut 2
			guiradio [@@falsetext] [@@(_ls_getfiltername $arg1 1)] 0 [
				(_ls_getfiltername [@@@arg1] 0) = 1
				_ls_updategui_total
			]
			guistrut 2
			guiradio [@@truetext] [@@(_ls_getfiltername $arg1 1)] 1 [
				(_ls_getfiltername [@@@arg1] 0) = 1
				_ls_updategui_total
			]
		])
		result [guispring; guilist [@@ctrls];]
	] 1 [
		createine (_ls_getfiltername $arg1 0) 0
		if (!=s $falsetext ".") [
			createine (_ls_getfiltername $arg1 1) 1
			ctrls = (concat $ctrls [
				guistrut 2
				guicheckbox [@@falsetext] [@@(_ls_getfiltername $arg1 1)] 0 1 [
					(_ls_getfiltername [@@@arg1] 0) = 1
					_ls_updategui_total
				]
			])
		] [
			createine (_ls_getfiltername $arg1 1) 0
			ctrls = (concat $ctrls [
				guistrut 2
				guicheckbox [@@truetext] [@@(_ls_getfiltername $arg1 1)] 1 0 [
					(_ls_getfiltername [@@@arg1] 0) = 1
					_ls_updategui_total
				]
			])
		]
		result [guispring; guilist [@@ctrls];]
	] 0 [
		(_ls_getfiltername $arg1 0) =
		(_ls_getfiltername $arg1 1) =
		result [guispring; guibar;]
	]
]

// _ls_genfilterelems
// Adds controls for all filters to the gui.
_ls_genfilterelems = [
	loopconcat c (listlen $_ls_list_filters_checks) [
		_ls_genfilter $c
	]
]

// _ls_checkfilter <MODE>
_ls_checkfilter = [
	|| [! $_ls_filter_enabled] [
		local useit
		useit = 1
		loop i (listlen $_ls_list_filters_checks) [
			// TODO use loopwhile
			if $useit [
				if (getalias (_ls_getfiltername $i 0)) [
					useit = (= $(_ls_getfiltername $i 1) ((at $_ls_list_filters_checks $i) $arg1))
				]
			]
		]
		result $useit
	]
]

// _ls_gettotalfiltered
// Returns total counters filtered by gui controls.
// TODO use lists for flags
_ls_gettotalfiltered = [
	local total
	if (=s $arg2 "") [
		arg2 = (_ls_getcounterflags $arg1)
	]
	looplist m $_ls_list_modes [
		if (_ls_checkfilter $m) [
			// FIXME derp, gui does not get updated (yet)
			//if $_ls_setting_save_current [
				//if (= $m (getmode)) [
					//+= total (_ls_getstats_current $arg1 $arg2)
				//]
			//]
			total = (_ls_applycounters $total (_ls_getstats $m))
		]
	]
	result $total
]

// _ls_genstatselems <COUNTERS> <FLAGS>
// Returns gui elements for all counters.
_ls_genstatselems = [
	_ls_loopdisplays caption disp $arg1 $arg2 [
		result [guilist [
			guitext [@@@caption] 0
			guispring
			guitext [@@@disp] 0
		];]
	]
]


// Current stats gui
newgui _ls_current [
	_ls_loopdisplays caption disp (_ls_getstats_current) $_ls_flag_showin_current [
		guilist [
			guitext $caption 0
			guispring
			guitext $disp 0
		]
	]
	guistrut 1
	if $_ls_setting_save_current [] [
		guicheckbox "Auto-reactivate" _ls_setting_save_reactivate 1 0
	]
	guicheckbox "Save current game" _ls_setting_save_current 1 0 [_ls_updategui_total]
	guibutton "Back" [cleargui 1] "arrow_bw"
] "Current game stats"

// _ls_genintsetting <TEXT> <AFTER> <WIDTH> <VAR> <DEFAULT>
_ls_genintsetting = [
	result [
		guilist [
			guitext (tabify [@@@arg1] 4)
			guistrut 1
			guifield [@@@arg4] [@@@arg3] [@@@arg4 = (? (> $[@@@@arg4] 0) $[@@@@arg4] [@@@@arg5])]
			guistrut 1
			guitext [@@@arg2] 0
		]
	]
]

_ls_doguireset = [
	cases $arg1 "history" [
		_ls_reset_history
	] "stats" [
		_ls_reset_stats
	] "settings" [
		_ls_reset_settings
	] "full" [
		_ls_reset_all
	]
	_ls_updategui
]

newgui _ls_reset_usure [
	guistayopen [
		guitext "Are you sure?"
		guistrut 0.5
		guibutton "Yes" [_ls_doguireset $_ls_gui_currentreset; _ls_gui_currentreset =; cleargui 2]
		guibutton "No"  [_ls_gui_currentreset =; cleargui 2]
	]
] "Reset"

newgui _ls_reset [
	guistayopen [
		guibutton "History" [_ls_gui_currentreset = "history"; showgui _ls_reset_usure]
		guibutton "Stats" [_ls_gui_currentreset = "stats"; showgui _ls_reset_usure]
		guibutton "Settings" [_ls_gui_currentreset = "settings"; showgui _ls_reset_usure]
		guibutton "Everything" [_ls_gui_currentreset = "full"; showgui _ls_reset_usure]
		guistrut 0.5
		guibutton "Back" [cleargui 1] "arrow_bw"
	]
] "Reset" [_ls_gui_currentreset =]

newgui _ls_settings [
	guistayopen [
		guicheckbox "Reactivate stats saving after game" _ls_setting_save_reactivate
		guicheckbox "Always save history" _ls_setting_save_history_always
		guicheckbox "Show killstreaks" _ls_setting_echo_killstreak
		guicheckbox "Show stats after game" _ls_setting_echo_postgame
		guistrut 0.5
		guibutton "Reset..." [showgui _ls_reset]
		guistrut 0.5
		guicheckbox "Advanced" _ls_setting_settings_advanced
		if $_ls_setting_settings_advanced [
			guibar
			@@@(_ls_genintsetting "TK poll interval:" "ms" 4 _ls_setting_tkpollinterval 20)
			@@@(_ls_genintsetting "Stats poll interval:" "ms" 4 _ls_setting_pollinterval 100)
			@@@(_ls_genintsetting "History limit:" "entries" 4 _ls_setting_history_max 50)
			@@@(_ls_genintsetting "History rows/tab:" "rows" 4 _ls_setting_history_tabrows 25)
			@@@(_ls_genintsetting "Killstreak timeout" "ms" 4 _ls_setting_killstreak_timeout 2000)
			guibar
		]
		guistrut 0.5
		guibutton "Back" [cleargui 1] "arrow_bw"
	]
] "Local Stats Settings" [_ls_gui_currentreset =]

// _ls_genhistoryelements
// Creates controls showing the history.
_ls_genhistoryelements = [
	if (<= (_ls_gethistorylength) 0) [
		result [guistrut 1; guistrut 50 1; guititle "There are no games yet."; guistrut 1.5]
	] [
		local i col row tab ctrls addtab getcolvarname colcount
		colcount = (+ 1 (_ls_getdisplaycount $_ls_flag_showin_history))
		do [
			local @(loopconcat d $colcount [concatword col_ $d])
			getcolvarname = [concatword col_ $arg1]
			addtab = [
				ctrls = (concatword $ctrls (? (> $tab 1) [guitab @tab;]) [guilist [
					@@(loopconcatword col $colcount [
						result [guispring; guilist [@@(result $(getcolvarname $col))];]
					])
				];])
				row = 0
				++ tab
			]

			row = 0
			tab = 1
			//loop i $_ls_history_count [
			i = 0
			looplist entry (_ls_gethistory) [
				if (>= $row $_ls_setting_history_tabrows) [
					addtab
				]
				col = 0
				_ls_loopdisplays caption disp $entry $_ls_flag_showin_history [
					if (= $row 0) [
						(getcolvarname $col) = [guilist [guispring; guistrut 1; guitext [@@@(concatword "^f0" $caption)] 0];]
					]
					(getcolvarname $col) = (concatword $(getcolvarname $col) [guilist [guispring; guistrut 1; guitext [@@@(concatword "^f6" $disp)] 0];])
					++ col
				]
				if (= $row 0) [
					(getcolvarname $col) = (concatword [guispring; guistrut 1;])
				]
				(getcolvarname $col) = (concatword $(getcolvarname $col) [guilist [guispring; guistrut 1; guibutton "" [_ls_rmhistory @@@i; _ls_updategui_history] "exit"];])
				++ row
				++ i
			]
			addtab
			result $ctrls
		]
	]
]

_ls_creategui_history = [
	result [guistayopen [
		@@(_ls_genhistoryelements)
	]]
]

// _ls_updategui_history
// Recreates the history gui.
_ls_updategui_history = [
	newgui _ls_history (_ls_creategui_history) "History"
]
_ls_updategui_history

// _ls_gentotalgui
// Creates the gui and returns the body.
_ls_gentotalgui = [
	result [guistayopen [
		guilist [
			@@@(if $_ls_filter_enabled [
				result [
					guilist [
						@@(_ls_genfilterelems)
					]
					guibar
				]
			])
			guilist [
				@@@@(_ls_genstatselems (_ls_gettotalfiltered) $_ls_flag_showin_total)
				guistrut 0.5
				guicheckbox "Filter" _ls_filter_enabled 1 0 [_ls_updategui_total]
				guicheckbox "Save current game" _ls_setting_save_current 1 0 [_ls_updategui_total]
				guistrut 0.5
				guibutton "Current game stats" [showgui _ls_current]
				guibutton "Game history" [showgui _ls_history]
				guibutton "Settings" [showgui _ls_settings]
			]
		]
	]]
]

// _ls_updategui_total
// Recreates the total gui.
_ls_updategui_total = [
	newgui _ls_filtered (_ls_gentotalgui) "Local Stats"
]
_ls_updategui_total

// _ls_updategui
// Updates all guis.
_ls_updategui = [
	_ls_updategui_total
	_ls_updategui_history
]





// ================
//  User functions
// ================



// savestatsreactivate 0/1
// Sets and returns whether savestats should be set to 1 after this game
savestatsreactivate = [
	if $numargs [
		_ls_setting_save_reactivate = (!= $arg1 0)
	]
	result $_ls_setting_save_reactivate
]

// savestats 0/1
// Sets and returns whether the stats of the current game should be saved.
savestats = [
	if (&& [> $numargs 0] [!= (!= $arg1 0) $_ls_setting_save_current]) [
		_ls_setting_save_current = (!= $arg1 0)
		_ls_updategui_total
	]
	result $_ls_setting_save_current
]

// maxgamehistory <MAX>
// sets the maximum number of entries in the game history.
// NOTE: deletes old entries exceeding this limit.
maxgamehistory = [
	if (> $numargs 0) [
		_ls_setting_history_max = (max $arg1 0)
		_ls_checkhistorylimit
	]
	result $_ls_setting_history_max
]

// Updates and shows the total stats gui.
localstats = [ _ls_updategui_total; showgui _ls_filtered ]
// Updates and shows the history gui.
localstatshistory = [ _ls_updategui_history; showgui _ls_history ]
// Shows the current game stats gui.
localstatscurrent = [ showgui _ls_current ]





// =========
//  The end
// =========



// vim:set sw=4 ts=4 sts=0 noet sta sr ft=cube fdm=syntax:
