// File:		permstats.cfg
// Author:		FerreusRemedium
// Created:		2013-03-13
// Last Change: 2013-03-14

createine = [ if (=s (getalias $arg1) "") [ $arg1 = $arg2 ] ]

// Normal counters
_ps_list_counters = "Frags: Deaths: Scores: Damage: Shots: Tks: Suicides: Time: Games:"
_ps_list_counters_getters = "getfrags getdeaths getflags gettotaldamage gettotalshots _ps_gettks _ps_getsuicides _ps_gettime _ps_getroundcount"
// Functions called to display the counters
_ps_list_counters_displayers = ". . . . . . . _ps_getstrtime ."

// Counters derived from others
_ps_list_specials = "Accuracy: KpD: KpM:"
_ps_list_specials_methods = "_ps_calcaccuracy _ps_calckpd _ps_calckpm"

// Gamemode filters
_ps_list_filters = "ffa team . normal . insta . effic . ctf . protect . collect . hold . capture . regen . tactics mp sp"
_ps_list_filters_checks = "m_teammode _ps_m_normal m_insta m_efficiency m_ctf m_protect m_collect m_hold m_capture m_regencapture m_tactics m_sp"

// Included gamemodes
_ps_list_modes = "-3 -2 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22"
// not used yet
_ps_list_modes_names = "sp dmsp ffa teamplay instagib instateam effic efficteam tactics tacteam capture regen ctf instactf protect instaprotect hold instahold efficctf efficprotect effichold collect instacollect efficcollect"

// teammodes:   ffa teamplay
// teamplay:    none ctf protect hold collect
// gearmodes:   none insta effic
// uniqueffa:   tactics
// uniqueteam:  tacteam capture regen

_ps_m_normal = [ result (&& [! (m_insta $arg1)] [! (m_efficiency $arg1)]) ]

createine _ps_last_isconnected (isconnected)
createine _ps_last_mode (getmode)
createine _ps_last_mapname (mapname)
createine _ps_last_timeremaining (timeremaining)
createine _ps_last_deaths (getdeaths)

createine _ps_stats_roundindex 0
createine _ps_apply_current_game 1

createine _ps_current_tks 0
createine _ps_current_suicides 0

_ps_pollinterval = 100
_ps_tkpollinterval = 20

// TODO do not count frags from before leaving a server TEST





// ==================
//  Helper Functions
// ==================



+= = [ $arg1 = (+ (getalias $arg1) $arg2); result $$arg1 ]
++ = [ $arg1 = (+ (getalias $arg1) 1); result $$arg1 ]





// ==============================
//  Teamkill and Suicide polling
// ==============================



// stop already running versions
// TODO doesn't count if tked and suicided at the same time TEST
_ps_polltksd = []
sleep (* 2 $_ps_tkpollinterval) [
	// polls frags and deaths to count tks
	_ps_polltksd = [
		sleep $_ps_tkpollinterval [
			do [
				local fcmp
				fcmp = (- @@(getfrags) (getfrags))
				if (> $fcmp 0) [
					local dcmp
					dcmp = (- (getdeaths) @@@(getdeaths))
					echo fcmp= $fcmp dcmp= $dcmp
					if (>= $dcmp 0) [ // in case the game has ended
						+= _ps_current_suicides $dcmp
						+= _ps_current_tks (- $fcmp $dcmp)
						_ps_addstats START (indexof $_ps_list_counters_getters "getfrags") (- 0 $fcmp)
						echo suicides: $_ps_current_suicides  tks: $_ps_current_tks
					]
				]
			]
			_ps_polltksd
		]
	]
	_ps_polltksd
]





// =================
//  Special getters
// =================



// returns tks counted by _ps_polltksd
_ps_gettks = [
	result $_ps_current_tks
]
// returns suicides counted by _ps_polltksd
_ps_getsuicides = [
	result $_ps_current_suicides
]

_ps_gettime = [
	if (isconnected) [result (- 0 (timeremaining))] [result 0]
]

_ps_zeros = [
	result (concatword (? (< $arg1 10) 0) $arg1)
]

// /_ps_getstrtimesub <SECONDS> <SUFFIX> <DIV> <MOD>
// Returns ((SECONS / DIV) % MOD) "SUFFIX".
// If the number without MOD is greater than 60, it ensures 2 digits.
// If the number is zero, it returns an empty string.
// If MOD is omitted or 0 it counts as a really big number.
_ps_getstrtimesub = [
	local s
	if (< $arg1 $arg3) [
		result ""
	] [
		if $arg4 [
			if (> $arg1 (* $arg3 $arg4)) [
				result (concatword (_ps_zeros (mod (div $arg1 $arg3) $arg4)) $arg2)
			] [
				result (concatword (mod (div $arg1 $arg3) $arg4) $arg2)
			]
		] [
			result (concatword (div $arg1 $arg3) $arg2)
		]
	]
]

_ps_getstrtime = [
	if $arg1 [
		result (concatword (_ps_getstrtimesub $arg1 "h" 3600) (_ps_getstrtimesub $arg1 "m" 60 60) (_ps_getstrtimesub $arg1 "s" 1 60))
	] [
		result -
	]
]

// /_ps_getroundcount
// Returns 0 if the round round since the last call has changed.
// Returns 1 if it is the same round.
_ps_getroundcount = [
	if (= $_ps_roundindex_last $_ps_stats_roundindex) [
		result 1
	] [
		_ps_roundindex_last = $_ps_stats_roundindex
		result 0
	]
]
createine _ps_roundindex_last -1





// ================
//  Stats counting
// ================



// /_ps_getcountername <MODE> <COUNTER>
// <MODE> TMP or the gamemode id
// <COUNTER> Name/index of the counter
_ps_getcountername = [
	result (concatword _ps_stats_ $arg1 _ $arg2)
]

_ps_addstats = [
	//local varname
	//varname = (_ps_getcountername $arg1 $arg2)
	//if (|| $arg3 (getalias $varname)) [
		//+= $varname $arg3
	if $arg3 [
		varname = (_ps_getcountername $arg1 $arg2)
		+= $$varname $arg3
		if $$varname [] [$varname = ""]
	]
]

_ps_setstats = [
	local varname
	varname = (_ps_getcountername $arg1 $arg2)
	if (|| $arg3 (getalias $varname)) [
		$varname = $arg3
	]
	if (getalias $varname) [] [$varname = ""]
]

// /_ps_getstats <MODE> <COUNTER>
// same args as /_ps_getcountername
// returns value of a counter or 0 if it does not exist yet
_ps_getstats = [
	result (|| (getalias (_ps_getcountername $arg1 $arg2)) 0)
]

// /_ps_getstats_tmp <COUNTER>
// returns COUNTER just for the game after _ps_apply was called.
_ps_getstats_tmp = [
	result (- (_ps_getstats TMP $arg1) (_ps_getstats START $arg1))
]

// checks whether the last game has ended
// FIXME
// Does not return 1 if the game is changed when all are true:
//  1. The game is switched directly without leaving the game to the main menu
//  2. The time remaining in the new game is less than in the old game
//  3. The player did not have any deaths in the old game
//  4. The new game is on the same map as the old game
_ps_changedgame = [
	result (|| [|| [!= (isconnected) $_ps_last_isconnected] [> (timeremaining) $_ps_last_timeremaining]] [|| [< (getdeaths) $_ps_last_deaths] [!=s $mapname $_ps_last_mapname]])
]

// saves information about current match for /_ps_changedgame
_ps_savegameinfo = [
	_ps_last_isconnected = (isconnected)
	_ps_last_mapname = (mapname)
	_ps_last_timeremaining = (timeremaining)
	_ps_last_deaths = (getdeaths)
]

// adds temporary counters to permanent counters
_ps_apply = [
	local addit
	addit = (>= (indexof $_ps_list_modes $_ps_last_mode) 0)
	echo addit= $addit mode= $_ps_last_mode
	loop i (listlen $_ps_list_counters_getters) [
		if $addit [
			_ps_addstats $_ps_last_mode $i (- (_ps_getstats TMP $i) (_ps_getstats START $i))
			echo _ps_addstats $_ps_last_mode $i "(-" (_ps_getstats TMP $i) (_ps_getstats START $i) ")"
		]
	]
]

// /_ps_apply_tmp <TAG>
// saves current match stats to temporary vars
// TAG: TMP or START
_ps_apply_tmp = [
	loop i (listlen $_ps_list_counters_getters) [
		_ps_setstats $arg1 $i ((at $_ps_list_counters_getters $i))
	]
]

// /_ps_onroundended
// Called after a game has ended.
_ps_onroundended = [
	echo "round ended"
	if $_ps_apply_current_game [
		_ps_apply
	]
	++ _ps_stats_roundindex
	_ps_apply_current_game = 1
	_ps_current_tks = 0
	_ps_current_suicides = 0
	_ps_updategui
	_ps_apply_tmp START
]

// /_ps_onstatscheck
// Called repeatedly during the game.
_ps_onstatscheck = [
	_ps_last_mode = (getmode)
	_ps_savegameinfo
	_ps_apply_tmp TMP
]

// /_ps_pollstatsd
// Calls /_ps_onroundended when a round has ended and
// keeps calling /_ps_onstatscheck repeatedly.
_ps_pollstatsd = [] // stop already running versions
sleep (* 2 $_ps_pollinterval) [
	_ps_pollstatsd = [
		if (_ps_changedgame) [
			_ps_onroundended
		]
		_ps_onstatscheck
		sleep $_ps_pollinterval [_ps_pollstatsd]
	]
	_ps_pollstatsd
]

// ====================
//  "special" counters
// ====================

// /_ps_round <F>
// Rounds float F to int.
_ps_round = [
	if (>= $arg1 0) [
		result (+ (+f $arg1 0.5) 0)
	] [
		result (+ (-f $arg1 0.5) 0)
	]
]

// /_ps_calcaccuracy <COUNTERLIST>
// Returns accuracy.
_ps_calcaccuracy = [
	local damage shots
	damage = (at $arg1 (indexof $_ps_list_counters_getters "gettotaldamage"))
	if $damage [
		shots = (at $arg1 (indexof $_ps_list_counters_getters "gettotalshots"))
		result (concatword (_ps_round (*f (divf $damage $shots) 100)) "%")
	] [
		result -
	]
]

// /_ps_calckpd <COUNTERLIST>
// Returns frags per death.
_ps_calckpd = [
	local frags deaths
	frags = (at $arg1 (indexof $_ps_list_counters_getters "getfrags"))
	if $frags [
		deaths = (at $arg1 (indexof $_ps_list_counters_getters "getdeaths"))
		result (divf (_ps_round (*f (divf $frags (max $deaths 1)) 100)) 100)
	] [
		result -
	]
]

// /_ps_calckpm <COUNTERLIST>
// Returns frags per minute.
_ps_calckpm = [
	local frags minutes
	frags = (at $arg1 (indexof $_ps_list_counters_getters "getfrags"))
	if $frags [
		minutes = (divf (at $arg1 (indexof $_ps_list_counters_getters "_ps_gettime")) 60)
		result (divf (_ps_round (*f (divf $frags (maxf $minutes 1.0)) 100)) 100)
	] [
		result -
	]
]





// ===========
//  GUI stuff
// ===========



createine _ps_filter_enabled 0

// total stats gui
newgui _ps_total [
	local total
	loop c (listlen $_ps_list_counters) [
		guilist [
			guitext (at $_ps_list_counters $c)
			total = 0
			looplist m $_ps_list_modes [
				+= total (_ps_getstats $m $c)
			]
			guitext $total
		]
	]
] "total"

_ps_getfiltervarname = [
	result (concatword _ps_filter_ $arg1 _ $arg2)
]

// /_ps_guifilter <INDEX>
// Adds filter controls to the gui.
_ps_guifilter = [
	local ctrls both falsetext truetext
	falsetext = (at $_ps_list_filters (<< $arg1 1))
	truetext = (at $_ps_list_filters (+ (<< $arg1 1) 1))
	createine (_ps_getfiltervarname $arg1 0) 0

	ctrls = [guicheckbox "on" @(_ps_getfiltervarname $arg1 0) 1 0 [_ps_updategui]]
	if (&& [!=s $truetext "."] [!=s $falsetext "."]) [
		createine (_ps_getfiltervarname $arg1 1) 1
		ctrls = (concat $ctrls [
			guistrut 2
			guiradio @falsetext @(_ps_getfiltervarname $arg1 1) 0 [
				(_ps_getfiltervarname @@arg1 0) = 1
				_ps_updategui
			]
			guistrut 2
			guiradio @truetext @(_ps_getfiltervarname $arg1 1) 1 [
				(_ps_getfiltervarname @@arg1 0) = 1
				_ps_updategui
			]
		])
	] [
		if (!=s $falsetext ".") [
			createine (_ps_getfiltervarname $arg1 1) 1
			ctrls = (concat $ctrls [
				guistrut 2
				guicheckbox @falsetext @(_ps_getfiltervarname $arg1 1) 0 1 [
					(_ps_getfiltervarname @@arg1 0) = 1
					_ps_updategui
				]
			])
		]
		if (!=s $truetext ".") [
			createine (_ps_getfiltervarname $arg1 1) 0
			ctrls = (concat $ctrls [
				guistrut 2
				guicheckbox @truetext @(_ps_getfiltervarname $arg1 1) 1 0 [
					(_ps_getfiltervarname @@arg1 0) = 1
					_ps_updategui
				]
			])
		]
	]
	result $ctrls
]
// /_ps_guifiltercontrols
// Adds controls for all filters to the gui.
_ps_guifiltercontrols = [
	result (loopconcat c (listlen $_ps_list_filters_checks) [
		result [guilist [ @@(_ps_guifilter $c) ];]
	])
]

// _ps_gettotalfiltered <COUNTER>
// returns total value of COUNTER filtered by gui controls
_ps_gettotalfiltered = [
	local useit total
	looplist m $_ps_list_modes [
		useit = 1
		if $_ps_filter_enabled [
			loop i (listlen $_ps_list_filters_checks) [
				if $useit [
					if $(_ps_getfiltervarname $i 0) [
						useit = (= $(_ps_getfiltervarname $i 1) ((at $_ps_list_filters_checks $i) $m))
					]
				]
			]
		]
		if $useit [
			// TODO add current stats if (= $m (getmode))
			// derp, gui does not get updated (yet)
			if (= $m (getmode)) [
				+= total (- (_ps_getstats TMP $arg1) (_ps_getstats START $arg1))
			]
			+= total (_ps_getstats $m $arg1)
		]
	]
	result (|| $total 0)
]

// /_ps_guistatscontrols
// Adds contols for all counters to the gui.
_ps_guistatscontrols = [
	local . s ctrls i varname list @(loopconcat c (listlen $_ps_list_counters) [result (concatword total_ $c)])
	. = [if (&& [!= $arg1 0] [!=s $arg1 ""]) [ result $arg1 ] [ result - ]] // dummy display function
	ctrls = (loopconcat c (listlen $_ps_list_counters) [
		varname = (concatword total_ $c)
		$varname = (_ps_gettotalfiltered $c)
		result [guilist [
			guitext @@(at $_ps_list_counters $c) 0
			guispring
			guitext @@(concatword "^"" ((at $_ps_list_counters_displayers $c) $$varname) "^"") 0
		];]
	])

	ctrls = (concat $ctrls (loopconcat i (listlen $_ps_list_specials) [
		if (=s (getalias list) "") [
			list = (loopconcat c (listlen $_ps_list_counters) [
				result $(concatword total_ $c)
			])
		]
		s = ((at $_ps_list_specials_methods $i) $list)
		result [guilist [
			guitext @@(at $_ps_list_specials $i) 0
			guispring
			guitext @@(concatword "^"" (if (!=s $s "") [result $s] [result -]) "^"") 0
		];]
	]))
	result $ctrls
]

// /_ps_creategui
// Creates the gui and returns the body.
_ps_creategui = [
	result [
		guilist [
			guispring
			guicheckbox "filter" _ps_filter_enabled 1 0 [_ps_updategui]
			guispring
		]
		guilist [
			@@(if $_ps_filter_enabled [
				result [
					guilist [
						@@(_ps_guifiltercontrols)
					]
					guibar
				]
			] [
				result ""
			])
			guilist [
				guistrut 14 1
				@@@(_ps_guistatscontrols)
				guistrut 1
				guicheckbox "save current game" _ps_apply_current_game 1 0 [_ps_updategui]
			]
		]
	]
]

// /_ps_updategui
// Recreates the gui.
_ps_updategui = [
	newgui _ps_filtered (_ps_creategui) "permstats"
]
_ps_updategui

// /permstats
// Shows the gui.
permstats = [ showgui _ps_filtered ]

// vim:set sw=4 ts=4 sts=0 noet sta sr ft=cube fdm=syntax:
